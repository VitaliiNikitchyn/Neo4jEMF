
//get type of properties of the node
match (n) WHERE ID(n) = 170
WITH properties(n) as props
return props, apoc.meta.types(props)


// remove all elements excluding metamodel
MATCH (:EPackage)-[*0..2]->(m)
WITH collect(DISTINCT m) AS m
OPTIONAL MATCH (n) WHERE NOT n IN m
DETACH DELETE n

// get count of all nodes and all relationships
MATCH ()-[r]->()
WITH  COUNT(r) as refCount
MATCH (n)
RETURN COUNT(n), refCount


// clear db with apoc
CALL apoc.periodic.iterate("MATCH (n) return n", "DETACH DELETE n", {batchSize:8000})
YIELD batches, total return batches, total


// create nodes with dynamic labels; return IDs by alias
WITH [{alias: 'a1', label: 'LL', props: {a:10, b:20}},
{alias: 'a2', label: 'LL', props: {a:30}},
{alias: 'a3', label: 'LL', props: {a:40, b:50}}] as batch
UNWIND batch as row
CALL apoc.create.node([row.label], row.props) YIELD node
RETURN row.alias AS alias, id(node) AS id


// ref setter  upperBound == 1
MATCH (c:MindMap) WHERE ID(c)=811
MATCH (e:CentralTopic) WHERE ID(e)=813
OPTIONAL MATCH (c)-[r:centralTopic {containment:true}]->(:CentralTopic)
OPTIONAL MATCH (e)<-[{containment: true}]-(endNodeContainer)
WITH c, e, r, COUNT(endNodeContainer) = 0  AS predicate
FOREACH (ignoreMe IN CASE WHEN predicate THEN [1] ELSE [] END |
	DELETE r
	MERGE (c)-[:centralTopic {containment:true}]->(e))
RETURN predicate


//ref setter  upperBound > 1
MATCH (c:MindMap) WHERE ID(c)=811
MATCH (e:CentralTopic) WHERE ID(e)=813
OPTIONAL MATCH (c)-[r:centralTopic {containment:true}]->(:CentralTopic)
OPTIONAL MATCH (e)<-[{containment: true}]-(endNodeContainer)
WITH c, e, COUNT(r) < 2 AND COUNT(endNodeContainer) = 0 AS predicate
FOREACH (ignoreMe IN CASE WHEN predicate THEN [1] ELSE [] END |
  CREATE (c)-[r:$refName{containment:{containment}}]->(e))
RETURN predicate


//create whole subGraph
with [{alias:1,label:"A",props:{}}, {alias:2,label:"B",props:{}}, {alias:3,label:"C",props:{}}] as nodes,
  [{from:"1", to:"1"}, {from:"1", to:"2"}, {from:"2", to:"3"}, {from:"3", to:"3"}] AS refs
UNWIND nodes as n
CALL apoc.create.node([n.label], n.props) YIELD node
WITH apoc.map.fromPairs(collect([n.alias, node])) as map, refs
UNWIND refs as r
CALL apoc.create.relationship(apoc.map.get(map, r.from), "r", {}, apoc.map.get(map, r.to)) YIELD rel
RETURN rel


//get connected nodes
match (a) where id(a)=0
CALL apoc.path.expand(a, "marker>", null, 1, 1) YIELD path
RETURN nodes(path)[1] AS node, collect(ID(relationships(path)[0])) AS refID

//
val res = transaction.run("MATCH (p:EPackage)-->(c:EClass) WHERE ID(p)={ePackageID}" +
" OPTIONAL MATCH (c)-[:eSuperTypes]->(directST:EClass)" +
" WITH c, collect(directST) AS directST, collect(directST.name) AS directSTName" +
" WITH c, directST[0] AS base, directST[1..] AS d, directSTName" +
" UNWIND CASE WHEN d = [] THEN [null] ELSE d END AS directST" +
" WITH c, base, directST, directSTName" +
" OPTIONAL MATCH (c)-->(ownAttr:EAttribute)" +
" OPTIONAL MATCH (c)-->(ownRef:EReference)-[:eType]->(ownRT:EClass)" +
" OPTIONAL MATCH (directST)-[:eSuperTypes*0..]->(superClass:EClass)" +
" OPTIONAL MATCH (superClass)-->(superAttr:EAttribute)" +
" OPTIONAL MATCH (superClass)-->(superRef:EReference)-[:eType]->(superRT:EClass)" +
" WITH c, base.name AS baseName, directSTName," +
" collect(DISTINCT superRef{.*, endClass:superRT.name}) AS superRef," +
" collect(DISTINCT ownRef{.*, endClass:ownRT.name}) AS ownRef," +
" collect(DISTINCT superAttr) AS superAttr, collect(DISTINCT ownAttr) AS ownAttr" +
" RETURN c AS class, baseName, directSTName, superAttr, ownAttr, superRef, ownRef",
Values.parameters("ePackageID", packageID))